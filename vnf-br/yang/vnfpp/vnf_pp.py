# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_target_vnf_pp__vnf_pp_target(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/target. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__author','__description',)

  _yang_name = 'target'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'target']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnf_pp/target/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnf_pp/target/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnf_pp/target/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnf_pp/target/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /vnf_pp/target/version (string)
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /vnf_pp/target/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_author(self):
    """
    Getter method for author, mapped from YANG variable /vnf_pp/target/author (string)
    """
    return self.__author
      
  def _set_author(self, v, load=False):
    """
    Setter method for author, mapped from YANG variable /vnf_pp/target/author (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_author is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_author() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """author must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__author = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_author(self):
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnf_pp/target/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnf_pp/target/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  author = __builtin__.property(_get_author, _set_author)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('author', author), ('description', description), ])


class yc_origin_vnf_pp__vnf_pp_reports_snapshots_origin(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports/snapshots/origin. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__role','__host',)

  _yang_name = 'origin'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__host = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports', 'snapshots', 'origin']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/origin/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/origin/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /vnf_pp/reports/snapshots/origin/role (string)
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /vnf_pp/reports/snapshots/origin/role (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_host(self):
    """
    Getter method for host, mapped from YANG variable /vnf_pp/reports/snapshots/origin/host (string)
    """
    return self.__host
      
  def _set_host(self, v, load=False):
    """
    Setter method for host, mapped from YANG variable /vnf_pp/reports/snapshots/origin/host (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host(self):
    self.__host = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  role = __builtin__.property(_get_role, _set_role)
  host = __builtin__.property(_get_host, _set_host)


  _pyangbind_elements = OrderedDict([('id', id), ('role', role), ('host', host), ])


class yc_source_vnf_pp__vnf_pp_reports_snapshots_evaluations_source(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports/snapshots/evaluations/source. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__type','__version','__call',)

  _yang_name = 'source'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__call = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports', 'snapshots', 'evaluations', 'source']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/version (string)
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_call(self):
    """
    Getter method for call, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/call (string)
    """
    return self.__call
      
  def _set_call(self, v, load=False):
    """
    Setter method for call, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source/call (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_call is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_call() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """call must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__call = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_call(self):
    self.__call = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  version = __builtin__.property(_get_version, _set_version)
  call = __builtin__.property(_get_call, _set_call)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('type', type), ('version', version), ('call', call), ])


class yc_timestamp_vnf_pp__vnf_pp_reports_snapshots_evaluations_timestamp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports/snapshots/evaluations/timestamp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__stop',)

  _yang_name = 'timestamp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__stop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports', 'snapshots', 'evaluations', 'timestamp']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/timestamp/start (string)
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/timestamp/start (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_stop(self):
    """
    Getter method for stop, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/timestamp/stop (string)
    """
    return self.__stop
      
  def _set_stop(self, v, load=False):
    """
    Setter method for stop, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/timestamp/stop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stop() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__stop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stop(self):
    self.__stop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  stop = __builtin__.property(_get_stop, _set_stop)


  _pyangbind_elements = OrderedDict([('start', start), ('stop', stop), ])


class yc_timeseries_vector_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics_timeseries_vector(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports/snapshots/evaluations/metrics/timeseries-vector. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of timeseries values
  """
  __slots__ = ('_path_helper', '_extmethods', '__timestamp','__value',)

  _yang_name = 'timeseries-vector'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__timestamp = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timestamp", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="value", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports', 'snapshots', 'evaluations', 'metrics', 'timeseries-vector']

  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/timeseries_vector/timestamp (uint32)
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/timeseries_vector/timestamp (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timestamp", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timestamp", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timestamp", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/timeseries_vector/value (decimal64)
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/timeseries_vector/value (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="value", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="value", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="value", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)

  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  value = __builtin__.property(_get_value, _set_value)

  __choices__ = {'value': {'timeseries-vector': ['timestamp', 'value']}}
  _pyangbind_elements = OrderedDict([('timestamp', timestamp), ('value', value), ])


class yc_metrics_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports/snapshots/evaluations/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__unit','__scalar','__vector','__string_scalar','__string_vector','__timeseries_vector',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=6)), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)
    self.__string_scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="string-scalar", parent=self, choice=('value', 'string-scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__string_vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="string-vector", parent=self, choice=('value', 'string-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__timeseries_vector = YANGDynClass(base=YANGListType("timestamp",yc_timeseries_vector_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics_timeseries_vector, yang_name="timeseries-vector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="timeseries-vector", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports', 'snapshots', 'evaluations', 'metrics']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/scalar (decimal64)

    YANG Description: Single numeric value
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/scalar (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: Single numeric value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=6), is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/vector (decimal64)

    YANG Description: List of numeric values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/vector (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: List of numeric values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=6)), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=6)), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedPrecisionDecimalType(precision=6)), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='decimal64', is_config=True)


  def _get_string_scalar(self):
    """
    Getter method for string_scalar, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/string_scalar (string)

    YANG Description: Single string value
    """
    return self.__string_scalar
      
  def _set_string_scalar(self, v, load=False):
    """
    Setter method for string_scalar, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/string_scalar (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_string_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_string_scalar() directly.

    YANG Description: Single string value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="string-scalar", parent=self, choice=('value', 'string-scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """string_scalar must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="string-scalar", parent=self, choice=('value', 'string-scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__string_scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_string_scalar(self):
    self.__string_scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="string-scalar", parent=self, choice=('value', 'string-scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_string_vector(self):
    """
    Getter method for string_vector, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/string_vector (string)

    YANG Description: List of string values
    """
    return self.__string_vector
      
  def _set_string_vector(self, v, load=False):
    """
    Setter method for string_vector, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/string_vector (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_string_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_string_vector() directly.

    YANG Description: List of string values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="string-vector", parent=self, choice=('value', 'string-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """string_vector must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="string-vector", parent=self, choice=('value', 'string-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__string_vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_string_vector(self):
    self.__string_vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="string-vector", parent=self, choice=('value', 'string-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_timeseries_vector(self):
    """
    Getter method for timeseries_vector, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/timeseries_vector (list)

    YANG Description: List of timeseries values
    """
    return self.__timeseries_vector
      
  def _set_timeseries_vector(self, v, load=False):
    """
    Setter method for timeseries_vector, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics/timeseries_vector (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeseries_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeseries_vector() directly.

    YANG Description: List of timeseries values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("timestamp",yc_timeseries_vector_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics_timeseries_vector, yang_name="timeseries-vector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="timeseries-vector", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeseries_vector must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("timestamp",yc_timeseries_vector_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics_timeseries_vector, yang_name="timeseries-vector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="timeseries-vector", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)""",
        })

    self.__timeseries_vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeseries_vector(self):
    self.__timeseries_vector = YANGDynClass(base=YANGListType("timestamp",yc_timeseries_vector_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics_timeseries_vector, yang_name="timeseries-vector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="timeseries-vector", parent=self, choice=('value', 'timeseries-vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  unit = __builtin__.property(_get_unit, _set_unit)
  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)
  string_scalar = __builtin__.property(_get_string_scalar, _set_string_scalar)
  string_vector = __builtin__.property(_get_string_vector, _set_string_vector)
  timeseries_vector = __builtin__.property(_get_timeseries_vector, _set_timeseries_vector)

  __choices__ = {'value': {'scalar': ['scalar'], 'vector': ['vector'], 'string-scalar': ['string_scalar'], 'string-vector': ['string_vector'], 'timeseries-vector': ['timeseries_vector']}}
  _pyangbind_elements = OrderedDict([('name', name), ('unit', unit), ('scalar', scalar), ('vector', vector), ('string_scalar', string_scalar), ('string_vector', string_vector), ('timeseries_vector', timeseries_vector), ])


class yc_evaluations_vnf_pp__vnf_pp_reports_snapshots_evaluations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports/snapshots/evaluations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__source','__timestamp','__metrics',)

  _yang_name = 'evaluations'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__source = YANGDynClass(base=yc_source_vnf_pp__vnf_pp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    self.__timestamp = YANGDynClass(base=yc_timestamp_vnf_pp__vnf_pp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports', 'snapshots', 'evaluations']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source (container)
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/source (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_vnf_pp__vnf_pp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_vnf_pp__vnf_pp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=yc_source_vnf_pp__vnf_pp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/timestamp (container)
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/timestamp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timestamp_vnf_pp__vnf_pp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timestamp_vnf_pp__vnf_pp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=yc_timestamp_vnf_pp__vnf_pp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics (list)
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metrics_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnf_pp__vnf_pp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  source = __builtin__.property(_get_source, _set_source)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  metrics = __builtin__.property(_get_metrics, _set_metrics)


  _pyangbind_elements = OrderedDict([('id', id), ('source', source), ('timestamp', timestamp), ('metrics', metrics), ])


class yc_snapshots_vnf_pp__vnf_pp_reports_snapshots(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports/snapshots. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__trial','__origin','__evaluations',)

  _yang_name = 'snapshots'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__trial = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)
    self.__origin = YANGDynClass(base=yc_origin_vnf_pp__vnf_pp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    self.__evaluations = YANGDynClass(base=YANGListType("id",yc_evaluations_vnf_pp__vnf_pp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports', 'snapshots']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnf_pp/reports/snapshots/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_trial(self):
    """
    Getter method for trial, mapped from YANG variable /vnf_pp/reports/snapshots/trial (uint32)
    """
    return self.__trial
      
  def _set_trial(self, v, load=False):
    """
    Setter method for trial, mapped from YANG variable /vnf_pp/reports/snapshots/trial (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trial() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trial must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)""",
        })

    self.__trial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trial(self):
    self.__trial = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /vnf_pp/reports/snapshots/origin (container)
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /vnf_pp/reports/snapshots/origin (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_origin_vnf_pp__vnf_pp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_origin_vnf_pp__vnf_pp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=yc_origin_vnf_pp__vnf_pp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)


  def _get_evaluations(self):
    """
    Getter method for evaluations, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations (list)
    """
    return self.__evaluations
      
  def _set_evaluations(self, v, load=False):
    """
    Setter method for evaluations, mapped from YANG variable /vnf_pp/reports/snapshots/evaluations (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evaluations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evaluations() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_evaluations_vnf_pp__vnf_pp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evaluations must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_evaluations_vnf_pp__vnf_pp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)""",
        })

    self.__evaluations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evaluations(self):
    self.__evaluations = YANGDynClass(base=YANGListType("id",yc_evaluations_vnf_pp__vnf_pp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  trial = __builtin__.property(_get_trial, _set_trial)
  origin = __builtin__.property(_get_origin, _set_origin)
  evaluations = __builtin__.property(_get_evaluations, _set_evaluations)


  _pyangbind_elements = OrderedDict([('id', id), ('trial', trial), ('origin', origin), ('evaluations', evaluations), ])


class yc_reports_vnf_pp__vnf_pp_reports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp/reports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__test','__snapshots',)

  _yang_name = 'reports'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__test = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)
    self.__snapshots = YANGDynClass(base=YANGListType("id",yc_snapshots_vnf_pp__vnf_pp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp', 'reports']

  def _get_test(self):
    """
    Getter method for test, mapped from YANG variable /vnf_pp/reports/test (uint32)
    """
    return self.__test
      
  def _set_test(self, v, load=False):
    """
    Setter method for test, mapped from YANG variable /vnf_pp/reports/test (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)""",
        })

    self.__test = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test(self):
    self.__test = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='uint32', is_config=True)


  def _get_snapshots(self):
    """
    Getter method for snapshots, mapped from YANG variable /vnf_pp/reports/snapshots (list)
    """
    return self.__snapshots
      
  def _set_snapshots(self, v, load=False):
    """
    Setter method for snapshots, mapped from YANG variable /vnf_pp/reports/snapshots (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snapshots is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snapshots() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_snapshots_vnf_pp__vnf_pp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snapshots must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_snapshots_vnf_pp__vnf_pp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)""",
        })

    self.__snapshots = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snapshots(self):
    self.__snapshots = YANGDynClass(base=YANGListType("id",yc_snapshots_vnf_pp__vnf_pp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

  test = __builtin__.property(_get_test, _set_test)
  snapshots = __builtin__.property(_get_snapshots, _set_snapshots)


  _pyangbind_elements = OrderedDict([('test', test), ('snapshots', snapshots), ])


class yc_vnf_pp_vnf_pp__vnf_pp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__author','__description','__timestamp','__target','__reports',)

  _yang_name = 'vnf-pp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    self.__target = YANGDynClass(base=yc_target_vnf_pp__vnf_pp_target, is_container='container', yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    self.__reports = YANGDynClass(base=YANGListType("test",yc_reports_vnf_pp__vnf_pp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='test', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf-pp']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnf_pp/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnf_pp/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnf_pp/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnf_pp/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /vnf_pp/version (string)
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /vnf_pp/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_author(self):
    """
    Getter method for author, mapped from YANG variable /vnf_pp/author (string)
    """
    return self.__author
      
  def _set_author(self, v, load=False):
    """
    Setter method for author, mapped from YANG variable /vnf_pp/author (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_author is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_author() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """author must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__author = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_author(self):
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnf_pp/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnf_pp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /vnf_pp/timestamp (string)
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /vnf_pp/timestamp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='string', is_config=True)


  def _get_target(self):
    """
    Getter method for target, mapped from YANG variable /vnf_pp/target (container)
    """
    return self.__target
      
  def _set_target(self, v, load=False):
    """
    Setter method for target, mapped from YANG variable /vnf_pp/target (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_target_vnf_pp__vnf_pp_target, is_container='container', yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_target_vnf_pp__vnf_pp_target, is_container='container', yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)""",
        })

    self.__target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target(self):
    self.__target = YANGDynClass(base=yc_target_vnf_pp__vnf_pp_target, is_container='container', yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)


  def _get_reports(self):
    """
    Getter method for reports, mapped from YANG variable /vnf_pp/reports (list)
    """
    return self.__reports
      
  def _set_reports(self, v, load=False):
    """
    Setter method for reports, mapped from YANG variable /vnf_pp/reports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reports() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("test",yc_reports_vnf_pp__vnf_pp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='test', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("test",yc_reports_vnf_pp__vnf_pp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='test', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)""",
        })

    self.__reports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reports(self):
    self.__reports = YANGDynClass(base=YANGListType("test",yc_reports_vnf_pp__vnf_pp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='test', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  author = __builtin__.property(_get_author, _set_author)
  description = __builtin__.property(_get_description, _set_description)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  target = __builtin__.property(_get_target, _set_target)
  reports = __builtin__.property(_get_reports, _set_reports)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('author', author), ('description', description), ('timestamp', timestamp), ('target', target), ('reports', reports), ])


class vnf_pp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-pp - based on the path /vnf-pp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Yang model for a VNF Performance Profile (vnf-pp) in the scope of IETF/BMWG
  """
  __slots__ = ('_path_helper', '_extmethods', '__vnf_pp',)

  _yang_name = 'vnf-pp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnf_pp = YANGDynClass(base=yc_vnf_pp_vnf_pp__vnf_pp, is_container='container', yang_name="vnf-pp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_vnf_pp(self):
    """
    Getter method for vnf_pp, mapped from YANG variable /vnf_pp (container)
    """
    return self.__vnf_pp
      
  def _set_vnf_pp(self, v, load=False):
    """
    Setter method for vnf_pp, mapped from YANG variable /vnf_pp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_pp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_pp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnf_pp_vnf_pp__vnf_pp, is_container='container', yang_name="vnf-pp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_pp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnf_pp_vnf_pp__vnf_pp, is_container='container', yang_name="vnf-pp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)""",
        })

    self.__vnf_pp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_pp(self):
    self.__vnf_pp = YANGDynClass(base=yc_vnf_pp_vnf_pp__vnf_pp, is_container='container', yang_name="vnf-pp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-pp', defining_module='vnf-pp', yang_type='container', is_config=True)

  vnf_pp = __builtin__.property(_get_vnf_pp, _set_vnf_pp)


  _pyangbind_elements = OrderedDict([('vnf_pp', vnf_pp), ])


